///*
// * vd_timemain.c
// *
// *  Created on: 27 бер. 2019 р.
// *      Author: KozakVF
// */
//
///* підключити бібліотеку, що забезпечує роботу з часом */
//#include "wk_atime64.h"
//
//
///****************************************************************/
//tkMAIN_status_t tkInit_VD(void){
///****************************************************************/
//	/* Ініціалізація роботи з часом - два випадки
//	 * 1) коли ініціалізація здійснюється вперше на контролері
//	 * (не треба зчитувати з регістрів дату, автоматично вводиться час і дата компіляції)
//	 * 2) коли це не перша ініціалізація
//	 *    зчитується дата з регістра..*/
//	volatile tkMAIN_status_t tkI=tkMAIN_UNKNOWN_Err;
//
//	while (tkI != tkMAIN_OK){
//		flash_status_t fs = FLASH_UNKNOWN_Err;
//		/* Якщо ініціалізація tk4 здійснюється не вперше */
//		if (f_ZeroTest() == ZERO_INIT_Cplt){
//			/* зчитати з регістрів збережений час і дату*/
//			HALRTC_AverageInit();
//			/* зчитати з флеш в память налаштування виробника*/
//			fs = f_VV300_FactorySets_Read();
//			if (fs != FLASH_OK){
//				f_PutErrRecord(ERR fs);
//				tkI=tkMAIN_FLASHErr;
//				break;
//			}
//			/* зчитати з флеш в память налаштування користувача */
//			fs =f_VV300_UserSets_Read();
//			if (fs != FLASH_OK){
//				f_PutErrRecord(ERR fs);
//				tkI=tkMAIN_FLASHErr;break;
//			}
//		}
//		else {
//			/* Якщо ініціалізація tk4 здійснюється вперше */
//			/* Iніціювати дату і час датою і часом компіляції */
//			HALRTC_ZeroInit();
//			/* Ініціювати налаштування виробника і користувача за замовчуванням */
//			f_FSsetInit();
//			f_UsetInit();
//			/* Записати на флеш
//			 *  налаштування виробника і користувача за замовчуванням */
//			fs=f_VV300_FactorySets_Write();
//			if (fs != FLASH_OK){
//				f_PutErrRecord(ERR fs);
//				tkI=tkMAIN_FLASHErr;break;
//			}
//			fs=f_VV300_UserSets_Write();
//			if (f_VV300_UserSets_Write() != FLASH_OK){
//				f_PutErrRecord(ERR fs);
//				tkI=tkMAIN_FLASHErr;
//				break;
//			}
//			/* Записати у регіст мітку про завершену первинну ініціалізацію контролера
//			 * #define ZERO_INIT_Cplt 0x1111 */
//			f_ZeroLabelWrite(ZERO_INIT_Cplt);
//		}
//		/* дата та час у форматі 64 */
//	    f_wk64_time_Init();
//
//	return tkI;
//}
///***********************************************************************************************
// *  БАЗОВИЙ ЦИКЛ
// ***********************************************************************************************/
//tkMAIN_status_t tkLoop(void){
//	/* В файлі wk_atime64.c оголошено і визначено дві змінні:
//	 * 1) Еліптичний час, це кількість секунд, що пройшли з 1900.01.01.00.00
//	 * volatile Time64_T wk_real64_value;
//	 * 2) Календартний час
//	 * struct tm *p_wk64_tm;
//	 * Наприклад, щоб вивести будь де календарний час можна:
//	 * 	 	snprintf((char*)strLow_menu, 17, "%4d/%02d/%02d %02d:%02d",
//	 			p_wk64_tm->tm_year+1900, роки відраховуються починаючи з 1900
//				p_wk64_tm->tm_mon+1,	 місяці - з нульового
//				p_wk64_tm->tm_mday,
//				p_wk64_tm->tm_hour,
//				p_wk64_tm->tm_min);
//	 * якщо в будь якому файлі додати #include "wk_atime64.h"
//	 * ці змінні доступні..
//	 * якщо потрібно - можна оголошувати інші змінні такого ж типу:
//	 *
//	 *
//	 *  Time64_T elipcetime = 0;
//	 *  Функції:
//	 *  отримати еліптичний час на момент виконання функції:
//	 *	f_wk64_time_Get(&elipcetime);
//		з нього отримати календарний час:
//		struct tm myTM = 0;
//		strucr tm *p_myTM = NULL;
//		p_myTM = &myTM;
//		p_myTM=localtime64(&elipcetime);
//		Якщо треба перетворити календарний час в еліптичний час:
//		Time64_T   newElipceTime = mktime64(p_myTM);
//
// 	 	Можна обновляти час кожен цикл,
//
//		f_wk64_time_Loop();
//		ця функція
//	 	 */
//
//	return 0;
//}
//
